{
  "author": {
    "name": "BRIK Teknologier",
    "email": "post@brik.no",
    "url": "http://www.brik.no"
  },
  "contributors": [
    {
      "name": "Jon Packer",
      "email": "contact@jonpacker.com"
    },
    {
      "name": "Helge Holm",
      "email": "helge.holm@brik.no"
    },
    {
      "name": "Magnus Hoff",
      "email": "magnus.hoff@brik.no"
    }
  ],
  "main": "lib/seraph.js",
  "name": "seraph",
  "description": "A thin and familiar layer between node and neo4j's REST api.",
  "version": "0.9.4",
  "repository": {
    "url": "https://github.com/brikteknologier/seraph"
  },
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha -R spec -t 10000 -s 2000",
    "quick-test": "USE_DIRTY_DATABASE=true NO_STOP=true ./node_modules/mocha/bin/mocha -R spec -t 3000 -s 2000"
  },
  "engines": {
    "node": "~0.10.0"
  },
  "license": "MIT",
  "dependencies": {
    "async": "~0.2.9",
    "naan": "~1.3.11",
    "underscore": "~1.5.1",
    "request": "~2.27.0"
  },
  "devDependencies": {
    "mocha": "~1.2.0",
    "disposable-seraph": "~0.2.3-neo4j-2.0.0-M03"
  },
  "readme": "# Seraph.js\n\nA terse & familiar binding to the [Neo4j](http://neo4j.org/) REST API that is \nidiomatic to [node.js](http://nodejs.org/).\n\n## Install\n\n```\nnpm install seraph\n```\n\n## Quick Example\n\n```javascript\nvar db = require(\"seraph\")(\"http://localhost:7474\");\n\ndb.save({ name: \"Test-Man\", age: 40 }, function(err, node) {\n  if (err) throw err;\n  console.log(\"Test-Man inserted.\");\n\n  db.delete(node, function(err) {\n    if (err) throw err;\n    console.log(\"Test-Man away!\");\n  });\n});\n```\n\n## Documentation\n\n<a name=\"seraph.db_list\" />\n### Initialization\n* [seraph](#seraph) - initialize the seraph client\n\n### Generic Operations\n\n* [query](#query) - perform a cypher query and parse the results\n* [rawQuery](#rawQuery) - perform a cypher query and return unparsed results\n\n### API Communication Operations\n\n* [operation](#operation) - create a representation of a REST API call\n* [call](#call) - take an operation and call it\n* [batch](#batch) - perform a series of atomic operations with one api call.\n\n### Node Operations\n* [save (node.save)](#node.save) - create or update a node\n* [read (node.read)](#node.read) - read a node\n* [find (node.find)](#node.find) - find a node using a predicate\n* [delete (node.delete)](#node.delete) - delete a node\n* [relate (node.relate)](#node.relate) - relate two nodes\n* [relationships (node.relationships)](#node.relationships) - read the \n  relationships of a node\n* [legacyindex (node.legacyindex)](#node.legacyindex) - add a node to a legacy \n  index\n* [label (node.label)](#node.label) - add a label to a node\n* [removeLabel (node.removeLabel)](#node.removeLabel) - remove a label from a \n  node\n* [nodesWithLabel (node.nodesWithLabel)](#node.nodesWithLabel) - fetch all nodes\n  with a label\n* [readLabels (node.readLabels)](#node.readLabels) - read the labels of a node\n  or all available labels.\n\n### Relationship Operations\n* [rel.create](#rel.create) - create a relationship\n* [rel.update](#rel.update) - update the properties of a relationship\n* [rel.read](#rel.read) - read a relationship\n* [rel.delete](#rel.delete) - delete a relationship\n\n### Constraint operations\n* [constraints.list](#constraints.list) - list constraints\n* [constraints.uniqueness.create](#constraints.uniqueness.create) - create a\n  uniqueness constraint\n* [constraints.uniqueness.createIfNone](#constraints.uniquness.createIfNone) - \n  create a uniqueness constraint if it doesn't already exist\n* [constraints.uniqueness.list](#constraints.uniqueness.list) - list uniqueness\n  constraints\n* [constraints.uniqueness.drop](#constraints.uniqueness.drop) - drop a uniqueness\n  constraint\n\n### Indexing operations\n* [index.create](#index.create) - create an index on a label and property name\n* [index.createIfNone](#index.createIfNone) - create an index or return the old \n  one\n* [index.list](#index.list) - read out the indexes for a label\n* [index.drop](#index.drop) - drop an index\n\n### Legacy Index Operations\n* [legacyindex.create](#legacyindex.create) - create an index\n* [legacyindex.add](#legacyindex.add) - add a nodes/rels to an index\n* [legacyindex.read](#legacyindex.read) - read nodes/rels from an index\n* [legacyindex.remove](#legacyindex.remove) - remove nodes/rels from an index\n* [legacyindex.delete](#legacyindex.delete) - delete an index\n* [legacyindex.getOrSaveUnique](#legacyindex.getOrSaveUnique) - get or save a node \n  using an index for uniqueness\n* [legacyindex.saveUniqueOrFail](#legacyindex.saveUniqueOrFail) - save a node \n  using an index to enforce uniqueness\n\n## Compatibility\n\nSeraph `~0.9.0` only works with Neo4j-2.0.0-RC1 and later.\n\n## Testing\n\nYou can test Seraph simply by running `npm test`. It will spin up its own neo4j \ninstance for testing. **Note** that the first time you run your tests (or change \nneo4j version), a new version of neo4j will need to be downloaded. That can,\nof course, take a little time.\n\n## Initialization\n<a name=\"seraph\" />\n### seraph([server|options])\n\nCreates and returns the Seraph instance.  If no parameters are given,\nassumes the Neo4J REST API is running locally at the default location\n`http://localhost:7474/db/data`.\n\n__Arguments__\n\n* `options` (default=`{ server: \"http://localhost:7474\", endpoint: \"/db/data\" }` - `server` is protocol and authority part of Neo4J REST API URI, and `endpoint` should be the path segment of the URI.\n* `server` (string) - Short form to specify server parameter only. `\"http://localhorse:4747\"` is equivalent to `{ server: \"http://localhorse:4747\" }`.\n\n__Example__\n\n```javascript\n// To http://localhost:7474/db/data\nvar dbLocal = require(\"seraph\")();\n\n// To http://example.com:53280/neo\nvar dbRemote = require(\"seraph\")({ server: \"http://example.com:53280\",\n                                   endpoint: \"/neo\" });\n\n// Copy node#13 from remote server\ndbRemote.read({ id: 13 }, function(err, node) {\n  if (err) throw err;\n  delete node.id; // copy instead of overwriting local node#13\n  dbLocal.save(node, function(err, nodeL) {\n    if (err) throw err;\n    console.log(\"Copied remote node#13 to \" +\n                \"local node#\" + nodeL.id.toString() + \".\");\n  });\n});\n```\n\n## Generic Operations\n\n<a name=\"query\" /><a name=\"rawQuery\"/>\n### query(query, [params,] callback), rawQuery(query, [params,] callback)\n\n`rawQuery` performs a cypher query and returns the results directly from the\nREST API.  \n`query` performs a cypher query and map the columns and results together.\n\n__Note__: if you're performing large queries it may be advantageous to use\n`queryRaw`, since `query` attempts to infer whole nodes and relationships that\nare returned (in order to transform them into a nicer format).\n\n__Arguments__\n\n* `query` - Cypher query as a format string.\n* `params` (optional, default=`{}`). Replace `{key}` parts in query string.  See \n  cypher documentation for details. **note** that if you want to send a list of\n  ids as a parameter, you should send them as an array, rather than a string\n  representing them (`[2,3]` rather than `\"2,3\"`).\n* `callback` - (err, result).  Result is an array of objects.\n\n__Example__\n\nGiven database:\n\n```javascript\n{ name: 'Jon', age: 23, id: 1 }\n{ name: 'Neil', age: 60, id: 2 }\n{ name: 'Katie', age: 29, id: 3 }\n// 1 --knows--> 2\n// 1 --knows--> 3\n```\n\nReturn all people Jon knows:\n\n```javascript\nvar cypher = \"START x = node({id}) \"\n           + \"MATCH x -[r]-> n \"\n           + \"RETURN n \"\n           + \"ORDER BY n.name\";\n\ndb.query(cypher, {id: 1}, function(err, result) {\n  if (err) throw err;\n  assert.deepEqual(result, [\n    { name: 'Katie', age: 29, id: 3 },\n    { name: 'Neil', age: 60, id: 2 }\n  ]);\n};\n\ndb.rawQuery(cypher, {id: 3}, function(err, result) {\n  if (err) throw err;\n  // result contains the raw response from neo4j's rest API. See\n  // http://docs.neo4j.org/chunked/milestone/rest-api-cypher.html\n  // for more info\n})\n```\n\n---------------------------------------\n\n<a name=\"operation\" />\n### operation(path, [method='get/post'], [data])\n\nCreate an operation object that will be passed to [call](#call). \n\n__Arguments__\n\n* `path` - the path fragment of the request URL with no leading slash. \n* `method` (optional, default=`'GET'`|`'POST'`) - the HTTP method to use. When \n  `data` is an  object, `method` defaults to 'POST'. Otherwise, `method` \n  defaults to `GET`.\n* `data` (optional) - an object to send to the server with the request.\n\n__Example__\n\n```javascript\nvar operation = db.operation('node/4285/properties', 'PUT', { name: 'Jon' });\ndb.call(operation, function(err) {\n  if (!err) console.log('Set `name` to `Jon` on node 4285!')\n});\n```\n\n---------------------------------------\n\n<a name=\"call\" />\n### call(operation, callback)\n\nPerform an HTTP request to the server.\n\nIf the body is some JSON, it is parsed and passed to the callback.If the status\ncode is not in the 200's, an error is passed to the callback. \n\n__Arguments__\n\n* `operation` - an operation created by [operation](#operation) that specifies\n  what to request from the server\n* `callback` - function(err, result, response). `result` is the JSON parsed body\n  from the server (otherwise empty). `response` is the response object from the\n  request.\n\n__Example__\n\n```javascript\nvar operation = db.operation('node/4285/properties');\ndb.call(operation, function(err, properties) {\n  if (err) throw err;\n\n  // `properties` is an object containing the properties from node 4285\n});\n```\n\n---------------------------------------\n\n<a name=\"batch\" />\n### Batching/transactions - `batch([operations, callback])`\n\nBatching provides a method of performing a series of operations atomically. You\ncould also call it a transaction. It has the added benefit of being performed\nall in a single call to the neo4j api, which theoretically should result in \nimproved performance when performing more than one operation at the same time.\n\nWhen you create a batch, you're given a new `seraph` object to use. All calls to\nthis object will be added to the batch. Note that once a batch is committed, you\nshould no longer use this object.\n\n* [How do I use it?](#how-do-i-use-it)\n* [What happens to my callbacks?](#what-happens-to-my-callbacks)\n* [Can I reference newly created nodes?](#can-i-reference-newly-created-nodes)\n* [I didn't use any callbacks. How can I find my results when the batch is done?](#i-didnt-use-any-callbacks-how-can-i-find-my-results-when-the-batch-is-done)\n* [What happens if one of the operations fails?](#what-happens-if-one-of-the-operations-fails)\n* [Can I nest batches?](#can-i-nest-batches)\n* [How can I tell if this `db` object is a batch operation?](#how-can-i-tell-if-this-db-object-is-a-batch-operation)\n\n#### How do I use it?\n\nThere's two ways. You can do the whole thing asynchronously, and commit the \ntransaction whenever you want, or you can do it synchronously, and have the \ntransaction committed for you as soon as your function is finished running.\nHere's a couple of examples of performing the same operations with batch \nsynchronously and asynchronously:\n\n##### Asynchronously\n\n```javascript\nvar txn = db.batch();\n\ntxn.save({ title: 'Kaikki Askeleet' });\ntxn.save({ title: 'Sinä Nukut Siinä' });\ntxn.save({ title: 'Pohjanmaa' });\n\ntxn.commit(function(err, results) {\n  /* results -> [{ id: 1, title: 'Kaikki Askeleet' },\n                 { id: 2, title: 'Sinä Nukut Siinä' },\n                 { id: 3, title: 'Pohjanmaa' }] */\n});\n```\n\n##### Synchronously\n\n**Note** - it's only the creation of operations that is synchronous. The actual\nAPI call is asynchronous still, of course.\n\n```javascript\ndb.batch(function(txn) {\n  txn.save({ title: 'Kaikki Askeleet' });\n  txn.save({ title: 'Sinä Nukut Siinä' });\n  txn.save({ title: 'Pohjanmaa' });\n}, function(err, results) {\n  /* results -> [{ id: 1, title: 'Kaikki Askeleet' },\n                 { id: 2, title: 'Sinä Nukut Siinä' },\n                 { id: 3, title: 'Pohjanmaa' }] */\n});\n```\n\n#### What happens to my callbacks?\n\nYou can still pass callbacks to operations on a batch transaction. They will\nperform as you expect, but they will not be called until after the batch has\nbeen committed. Here's an example of using callbacks as normal:\n\n```javascript\nvar txn = db.batch();\n\ntxn.save({ title: 'Marmoritaivas' }, function(err, node) {\n  // this code is not reached until `txn.commit` is called\n  // node -> { id: 1, title: 'Marmoritaivas' }\n});\n\ntxn.commit();\n```\n\n#### Can I reference newly created nodes?\n\nYes! Calling, for example, `node.save` will synchronously return a special object\nwhich you can use to refer to that newly created node within the batch.\n\nFor example, this is perfectly valid in the context of a batch transaction:\n\n```javascript\nvar txn = db.batch();\n\nvar singer = txn.save({name: 'Johanna Kurkela'});\nvar album = txn.save({title: 'Kauriinsilmät', year: 2008});\nvar performance = txn.relate(singer, 'performs_on', album, {role: 'Primary Artist'});\ntxn.rel.legacyindex('performances', performance, 'year', '2008');\n\ntxn.commit(function(err, results) {});\n```\n\n#### I didn't use any callbacks. How can I find my results when the batch is done?\n\nEach function you call on the batch object will return a special object that you\ncan use to refer to that call's results once that batch is finished (in \naddition to the intra-batch referencing feature mentioned above). The best\nway to demonstrate this is by example:\n\n```javascript\nvar txn = db.batch();\n\nvar album = txn.save({title: 'Hetki Hiljaa'});\nvar songs = txn.save([\n  { title: 'Olen Sinussa', length: 248 },\n  { title: 'Juurrun Tähän Ikävään', length: 271 }\n]);\n// note we can also use `songs` to reference the node that will be created\ntxn.relate(album, 'has_song', songs[0], { trackNumber: 1 });\ntxn.relate(album, 'has_song', songs[1], { trackNumber: 3 });\n\ntxn.commit(function(err, results) {\n  var album = results[album]; // album -> { title: 'Hetki Hiljaa', id: 1 }\n  var tracks = results[songs];\n  /* tracks -> [{ title: 'Olen Sinussa', length: 248, id: 2 },\n                { title: 'Juurrun Tähän Ikävään', length: 271, id: 3}] */\n});\n```\n\n#### What happens if one of the operations fails?\n\nThen no changes are made. Neo4j's batch transactions are atomic, so if one\noperation fails, then no changes to the database are made. Neo4j's own\ndocumentation has the following to say: \n> This service is transactional. If any of the operations performed fails \n> (returns a non-2xx HTTP status code), the transaction will be rolled back and\n> all changes will be undone.\n\n#### Can I nest batches?\n\nNo, as of now we don't support nesting batches as it tends to confuse the\nintra-batch referencing functionality. To enforce this, you'll find that the\nseraph-like object returned by `db.batch()` has no `.batch` function itself.\n\n#### How can I tell if this `db` object is a batch operation?\n\nLike so:\n\n```javascript\n// db.isBatch -> undefined\nvar txn = db.batch();\n// txn.isBatch -> true\nif (txn.isBatch) // Woo! I'm in a batch.\n```\n\n-------------\n\n## Node Operations\n\n<a name=\"node.save\" />\n### save(object, [label,]|[key, value,] callback)\n*Aliases: __node.save__*\n\nCreate or update a node. If `object` has an id property, the node with that id\nis updated. Otherwise, a new node is created. Returns the newly created/updated\nnode to the callback.\n\n** Note: using `node.save` with a `label` *does not* work in a batch. If you\nwant to create a node with label in a batch, you should call `node.save` without\na label, followed by `node.label` with a reference to the created node. **\n\n__Arguments__\n\n* `node` - an object to create or update\n* `label` - a label to label this node with. this is performed atomically, so if\n  labelling the node fails, the node is not saved/updated. supplying `label` is \n  exclusive with `key` and `value`. You may either specify a `label`, or a `key`\n  and a `value`, but all three. ** Note: using `node.save` with a `label` \n  *does not* work in a batch. If you want to create a node with label in a batch,\n  you should call `node.save` without a label, followed by `node.label` with a \n  reference to the created node. **\n* `key`, `value` (optional) - a property key and a value to update it with. This\n  allows you to only update a single property of the node, without touching any\n  others. If `key` is specified, `value` must also be. \n* `callback` - function(err, node). `node` is the newly saved or updated node. If\n  a create was performed, `node` will now have an id property. The returned \n  object is not the same reference as the passed object (the passed object will\n  never be altered).\n\n__Example__\n\n** Creating and updating a node **\n\n```javascript\n// Create a node\ndb.save({ name: 'Jon', age: 22, likes: 'Beer' }, function(err, node) {\n  console.log(node); // -> { name: 'Jon', age: 22, likes: 'Beer', id: 1 }\n  \n  // Update it\n  delete node.likes;\n  node.age++;\n  db.save(node, function(err, node) {\n    console.log(node); // -> { name: 'Jon', age: 23, id: 1 }\n  })\n})\n```\n\n** Creating a node with a label **\n\n```javascript\ndb.save({ name: 'Jon' }, 'Person', function(err, node) {\n  \n});\n```\n\n** Update a single property on a node **\n\n```javascript\ndb.save({ name: 'Jon', age: 23 }, 'Person', function(err, node) {\n  db.save(node, 'age', 24, function(err) {\n  });\n});\n```\n\n---------------------------------------\n\n<a name=\"node.read\" />\n### read(id|object, [property,] callback)\n*Aliases: __node.read__*\n\nRead a node.\n\n**Note**: If the node doesn't exist, Neo4j will return an exception. You can \ncheck if this is indicating that your node doesn't exist because\n`err.statusCode` will equal `404`. This is inconsistent with behaviour of\n[node.legacyindex.read](#legacyindex.read), but it is justified because the \nNeo4j REST api behaviour is inconsistent in this way as well. \n\n__Arguments__\n\n* `id | object` - either the id of the node to read, or an object containing an id\nproperty of the node to read.\n* `property` (optional) - the name of the property to read. if this is specified,\n  only the value of this property on the object is returned.\n* `callback` - function(err, node). `node` is an object containing the properties\nof the node with the given id.\n\n__Example__\n\n```javascript\ndb.save({ make: 'Citroen', model: 'DS4' }, function(err, node) {\n  db.read(node.id, function(err, node) {\n    console.log(node) // -> { make: 'Citroen', model: 'DS4', id: 1 }\n  })\n})\n```\n\n---------------------------------------\n\n<a name=\"node.delete\" />\n### delete(id|object, [force | property], [callback])\n*Aliases: __node.delete__*\n\nDelete a node.\n\n__Arguments__\n\n* `id | object` - either the id of the node to delete, or an object containing an id\nproperty of the node to delete.\n* `force` (optional - default = false) -  if truthy, will delete all the node's \n  relations prior to deleting the node.\n* `property` (optional) - if specified, delete only the property with this name\n  on the object. **note that you can either specify `property` or `force`, not\n  both, as force is meaningless when deleting a property**\n* `callback` - function(err). if `err` is falsy, the node has been deleted.\n\n__Example__\n\n```\ndb.save({ name: 'Jon' }, function(err, node) {\n  db.delete(node, function(err) {\n    if (!err) console.log('Jon has been deleted!');\n  })\n})\n```\n\n---------------------------------------\n\n<a name=\"node.find\" />\n### find(predicate, [any, [start,]] callback)\n*Aliases: __node.find__*\n\nPerform a query based on a predicate. The predicate is translated to a\ncypher query.\n\n__Arguments__\n\n* `predicate` - Partially defined object.  Will return elements which match\n  the defined attributes of predicate.\n* `any` (optional, default=`false`) - If true, elements need only match on one \n  attribute. If false, elements must match on all attributes.\n* `start` (optional, default=`'node(*)'`) - The scope of the search. For alternate\n  values, check the [neo4j docs on the cypher START command](http://docs.neo4j.org/chunked/stable/query-start.html).\n* `callback` - function(err, results) - `results` is an array of the resulting\n  nodes.\n\n__Example__\n\nGiven database content:\n\n```javascript\n{ name: 'Jon'    , age: 23, australian: true  }\n{ name: 'Neil'   , age: 60, australian: true  }\n{ name: 'Belinda', age: 26, australian: false }\n{ name: 'Katie'  , age: 29, australian: true  }\n```\n\nRetrieve all australians:\n\n```javascript\nvar predicate = { australian: true };\nvar people = db.find(predicate, function (err, objs) {\n    if (err) throw err;\n    assert.equals(3, people.length);\n};\n```\n\n---------------------------------------\n\n<a name=\"node.relationships\" />\n### relationships(id|object, [direction, [type,]] callback)\n**Aliases: __node.relationships__*\n\nRead the relationships involving the specified node.\n\n__Arguments__\n\n* `id | object` - either the id of a node, or an object containing an id property of\n  a node.\n* `direction` ('all'|'in'|'out') (optional unless `type` is passed, \n  default=`'all'`) - the direction of relationships to read. \n* `type` (optional, default=`''` (match all relationships)) - the relationship\n  type to find\n* `callback` - function(err, relationships) - `relationships` is an array of the\n  matching relationships\n\n__Example__\n\n```javascript\ndb.relationships(452, 'out', 'knows', function(err, relationships) {\n  // relationships = all outgoing `knows` relationships from node 452\n})\n```\n\n---------------------------------------\n\n<a name=\"node.label\" />\n### label(id|object(s), label(s), [replace,] callback)\n*Aliases: __node.label__*\n\nAdd a label to a node.\n\n__Arguments__\n\n* `id|object(s)` - either the id of the node to label, or an object containing an\n  id property of the node to label. can be an array of objects/ids.\n* `label(s)` - the label(s) to apply. can be an array of labels.\n* `replace` (optional) - if set to true, this label will replace any previous \n  labels.\n* `callback` - function(err). if err is falsy, the operation succeeded.\n\n__Example__\n\n```javascript\ndb.save({ make: 'Citroen', model: 'DS4' }, function(err, node) {\n  db.label(node, ['Car', 'Hatchback'], function(err) {\n    // `node` is now labelled with \"Car\" and \"Hatchback\"!\n  });\n})\n```\n\n---------------------------------------\n\n<a name=\"node.removeLabel\" />\n### removeLabel(id|object(s), label, callback)\n*Aliases: __node.removeLabel__*\n\nRemove a label from a node.\n\n__Arguments__\n\n* `id|object(s)` - either the id of the node to delabel, or an object containing \n  an id property of the node to delabel. can be an array of objects/ids.\n* `label` - the label to remove. cannot be an array.\n* `callback` - function(err). if err is falsy, the operation succeeded.\n\n__Example__\n\n```javascript\ndb.save({ make: 'Citroen', model: 'DS4' }, function(err, node) {\n  db.label(node, ['Car', 'Hatchback'], function(err) {\n    // `node` is now labelled with \"Car\" and \"Hatchback\"!\n    db.removeLabel(node, 'Hatchback', function(err) {\n      // `node` is now only labelled with \"Car\".\n    });\n  });\n})\n```\n\n---------------------------------------\n\n<a name=\"node.nodesWithLabel\" />\n### nodesWithLabel(label, callback)\n*Aliases: __node.nodesWithLabel__*\n\nFetch all of the nodes that are labelled with a specific label.\n\n__Arguments__\n\n* `label` - the label.\n* `callback` - function(err, results). results is always an array (assuming no\n  error), containing the nodes that were labelled with `label`. if no nodes were\n  labelled with `label`, `results` is an empty array.\n\n__Example__\n\n```javascript\ndb.save({ make: 'Citroen', model: 'DS4' }, function(err, node) {\n  db.label(node, ['Car', 'Hatchback'], function(err) {\n    db.nodesWithLabel('Car', function(err, results) {\n      results[0].model // -> 'DS4'\n    });\n  });\n})\n```\n\n---------------------------------------\n\n<a name=\"node.readLabels\" />\n### readLabels([node(s),] callback)\n*Aliases: __node.readLabels__*\n\nRead the labels of a node, or all labels in the database.\n\n__Arguments__\n\n* `node(s)` (optional) - the node to return the labels of. if not specified, every\n  label in the database is returned. can be an array of nodes.\n* `callback` - function(err, labels). labels is an array of labels.\n\n__Example__\n\n```javascript\ndb.save({ make: 'Citroen', model: 'DS4' }, function(err, node) {\n  db.label(node, ['Car', 'Hatchback'], function(err) {\n    db.readLabels(node, function(err, labels) {\n      //labels -> ['Car', 'Hatchback']\n    });\n  });\n})\n```\n\n---------------------------------------\n\n## Relationship Operations\n\n<a name=\"rel.create\" />\n<a name=\"node.relate\" />\n### rel.create(firstId|firstObj, type, secondId|secondobj, [properties], callback)\n*Aliases: __relate__, __node.relate__*\n\nCreate a relationship between two nodes.\n\n__Arguments__\n\n* `firstId | firstObject` - id of the start node or an object with an id property\n  for the start node\n* `type` - the name of the relationship\n* `secondId | secondObject` - id of the end node or an object with an id property\n  for the end node\n* `properties` (optional, default=`{}`) - properties of the relationship\n* `callback` - function(err, relationship) - `relationship` is the newly created\n  relationship\n\n__Example__\n\n```javascript\ndb.relate(1, 'knows', 2, { for: '2 months' }, function(err, relationship) {\n  assert.deepEqual(relationship, {\n    start: 1,\n    end: 2,\n    type: 'knows',\n    properties: { for: '2 months' },\n    id: 1\n  });\n});\n```\n\n---------------------------------------\n\n<a name=\"rel.update\" />\n### rel.update(relationship, [key, value,] callback)\n\nUpdate the properties of a relationship. __Note__ that you cannot use this\nmethod to update the base properties of the relationship (start, end, type) -\nin order to do that you'll need to delete the old relationship and create a new\none.\n\n__Arguments__\n\n* `relationship` - the relationship object with some changed properties\n* `key`, `value` (optional) - if a key and value is specified, only the property with\n  that key will be updated. the rest of the object will not be touched.\n* `callback` - function(err). if err is falsy, the update succeeded.\n\n__Example__\n\n```javascript\nvar props = { for: '2 months', location: 'Bergen' };\ndb.rel.create(1, 'knows', 2, props, function(err, relationship) {\n  delete relationship.properties.location;\n  relationship.properties.for = '3 months';\n  db.rel.update(relationship, function(err) {\n    // properties on this relationship in the database are now equal to\n    // { for: '3 months' }\n  });\n});\n```\n\n---------------------------------------\n\n<a name=\"rel.read\" />\n### rel.read(object|id, callback)\n\nRead a relationship.\n\n__Arguments__\n\n* `object | id` - the id of the relationship to read or an object with an id\n  property of the relationship to read.\n* `callback` - function(err, relationship). `relationship` is an object\n  representing the read relationship.\n\n__Example__\n\n```javascript\ndb.rel.create(1, 'knows', 2, { for: '2 months' }, function(err, newRelationship) {\n  db.rel.read(newRelationship.id, function(err, readRelationship) {\n    assert.deepEqual(newRelationship, readRelationship);\n    assert.deepEqual(readRelationship, {\n      start: 1,\n      end: 2,\n      type: 'knows',\n      id: 1,\n      properties: { for: '2 months' }\n    });\n  });\n});\n```\n\n---------------------------------------\n\n<a name=\"rel.delete\" />\n### rel.delete(object|id, [callback])\n\nDelete a relationship.\n\n__Arguments__\n\n* `object | id` - the id of the relationship to delete or an object with an id\n  property of the relationship to delete.\n* `callback` - function(err). If `err` is falsy, the relationship has been\n  deleted.\n\n__Example__\n\n```javascript\ndb.rel.create(1, 'knows', 2, { for: '2 months' }, function(err, rel) {\n  db.rel.delete(rel.id, function(err) {\n    if (!err) console.log(\"Relationship was deleted\");\n  });\n});\n```\n\n## Constraints Operations\n\n<a name=\"constraints.list\" />\n### constraints.list([label,] callback)\n\nList all constraints, or optionally all constraints for a label.\n\n__Arguments__\n\n* `label` (optional) - the label to list constraints for\n* `callback` - function(err, constraints). `constraints` is an array of\n  constraint objects. For example, \n  `[{type:'UNIQUENESS', label:'Person', property_keys['name']}]`\n\n__Example__\n\n```javascript\ndb.constraints.list('Person', function(err, constraints) {\n  console.log(constraints); \n  // -> [{ type: 'UNIQUENESS', label: 'Person', { property_keys: ['name'] }]\n});\n```\n\n---------------------------------------\n\n<a name=\"constraints.uniqueness.list\" />\n### constraints.uniqueness.list(label, [key,] callback)\n\nList all uniqueness constraints, or optionally fetch a uniqueness constraint for\n`key`.\n\n__Arguments__\n\n* `label` - the label to list uniqueness constraints for\n* `key` (optional) - if specified, retrieve any uniqueness constraint for this\n  property key.\n* `callback` - function(err, constraints). `constraints` is an array of\n  constraint objects. For example, \n  `[{type:'UNIQUENESS', label:'Person', property_keys['name']}]`. If none\n  existed, it is an empty array.\n\n__Example__\n\n```javascript\ndb.constraints.uniqueness.list('Person', 'name', function(err, constraints) {\n  console.log(constraints); \n  // -> [{ type: 'UNIQUENESS', label: 'Person', { property_keys: ['name'] }]\n});\n```\n\n---------------------------------------\n\n<a name=\"constraints.uniqueness.create\" />\n### constraints.uniqueness.create(label, key, callback)\n\nCreate a uniqueness constraint on the given label. Any node labelled with `label`\nwill be constrained to having a unique value for the given `key`. If it doesn't,\nattempting to label that node with `label` will return an error (unfortunately\ndue to the way neo4j handles these errors, the statusCode is 400 instead of 409,\nbut you can check with \n`err.neo4jCause.exception == 'ConstraintViolationException'`.\n\n__Arguments__\n\n* `label` - the label to create a uniqueness constraint for\n* `key` - the key that should be unique on nodes labelled with `label`\n* `callback` - function(err, constraint). `constraint` is a constraint object\n  representing the constraint that was created, e.g. \n  `[{type:'UNIQUENESS', label:'Person', property_keys['name']}]`. If the\n  constraint already existed, `err.statusCode == 409`.\n\n__Example__\n\n```javascript\n// any node labelled Person should have a unique `name`\ndb.constraints.uniqueness.create('Person', 'name', function(err, constraint) {\n  console.log(constraint); \n  // -> { type: 'UNIQUENESS', label: 'Person', { property_keys: ['name'] }\n});\n```\n\n---------------------------------------\n\n<a name=\"constraints.uniqueness.createIfNone\" />\n### constraints.uniqueness.createIfNone(label, key, callback)\n\nCreate a uniqueness constraint on the given label. If the constraint exists,\ndon't return an error, just return the existing constraint.\n\n__Arguments__\n\n* `label` - the label to create a uniqueness constraint for\n* `key` - the key that should be unique on nodes labelled with `label`\n* `callback` - function(err, constraint). `constraint` is a constraint object\n  representing the constraint that was created, e.g. \n  `[{type:'UNIQUENESS', label:'Person', property_keys['name']}]`. \n\n__Example__\n\n```javascript\n// any node labelled Person should have a unique `name`\ndb.constraints.uniqueness.createIfNone('Person', 'name', function(err, constraint) {\n  console.log(constraint); \n  // -> { type: 'UNIQUENESS', label: 'Person', { property_keys: ['name'] }\n  db.constraints.uniqueness.createIfNone('Person', 'name', function(err, constraint) {\n    console.log(err);\n    // -> undefined\n    console.log(constraint); \n    // -> { type: 'UNIQUENESS', label: 'Person', { property_keys: ['name'] }\n  });\n});\n```\n\n---------------------------------------\n\n<a name=\"constraints.uniqueness.drop\" />\n### constraints.uniqueness.drop(label, key, callback)\n\nDrop (remove) a uniqueness constraint.\n\n__Arguments__\n\n* `label` - the label to remove a uniqueness constraint from\n* `key` - the key on which to remove the uniqueness constraint\n* `callback` - function(err). if `err` is falsy, the constraint was successfully\n  dropped\n\n__Example__\n\n```javascript\n// any node labelled Person should have a unique `name`\ndb.constraints.uniqueness.create('Person', 'name', function(err, constraint) {\n  console.log(constraint); \n  // -> { type: 'UNIQUENESS', label: 'Person', { property_keys: ['name'] }\n  db.constraints.uniqueness.drop('Person', 'name', function(err) {\n    console.log(err);\n    // -> undefined\n    // the constraint has been dropped\n  });\n});\n```\n\n## Indexing Operations\n\n**For more of an overview on schema-based indexing, check out the [neo4j docs\non the subject](http://docs.neo4j.org/chunked/milestone/graphdb-neo4j-schema.html#graphdb-neo4j-schema-indexes).**\n\n<a name=\"index.create\" />\n### index.create(label, key, callback)\n\nCreate an index on `label` with `key`. Note that schema-based indexes are\nperformance-boosting only and do not imply any uniqueness constraints.\n\n__Arguments__\n\n* `label` - the label to create an index on\n* `key` - the key to index, i.e. `'name'`. Note that compound indexes are not\n  yet supported by neo4j-2\n* `callback` - function(err, index). `index` is an object that reflects the\n  index that was created, i.e. `{ label: 'Person', { property_keys: ['name'] }`.\n  Note that if you've already created the index, you'll get a conflict error. You\n  can check this by checking `err`'s `statusCode` property. `409` indicates a \n  conflict. You can avoid this by using [index.createIfNone](#index.createIfNone)\n\n__Example__\n\n```javascript\ndb.index.create('Person', 'name', function(err, index) {\n  console.log(index); // -> { label: 'Person', { property_keys: ['name'] }\n});\n```\n\n---------------------------------------\n\n<a name=\"index.createIfNone\" />\n### index.createIfNone(label, key, callback)\n\nCreate an index on `label` with `key`. Exactly the same as\n[index.create](#index.create) except it will not throw an error if it encounters\na conflict.\n\n__Arguments__\n\n* `label` - the label to create an index on\n* `key` - the key to index, i.e. `'name'`. Note that compound indexes are not\n  yet supported by neo4j-2\n* `callback` - function(err, index). `index` is an object that reflects the\n  index that was created, i.e. `{ label: 'Person', { property_keys: ['name'] }`.\n\n__Example__\n\n```javascript\ndb.index.createIfNone('Person', 'name', function(err, index) {\n  console.log(index); // -> { label: 'Person', { property_keys: ['name'] }\n});\n```\n\n---------------------------------------\n\n<a name=\"index.list\" />\n### index.list(label, callback)\n\nRetrieve a listing of the indexes on a label.\n\n__Arguments__\n\n* `label` - the label to retrieve indexes for\n* `callback` - function(err, indexes). `indexes` is an array of objects that\n  reflect the indexes on this label, i.e. \n  `[{ label: 'Person', { property_keys: ['name'] }]`.\n\n__Example__\n\n```javascript\ndb.index.list('Person', function(err, index) {\n  console.log(index); // -> [ { label: 'Person', { property_keys: ['name'] } ]\n});\n```\n\n---------------------------------------\n\n<a name=\"index.drop\" />\n### index.drop(label, key, callback)\n\nDrop an index from a label\n\n__Arguments__\n\n* `label` - the label to drop the index from\n* `key` - the key to drop the index from \n* `callback` - function(err). if `err` is falsy, the index was dropped \n  successfully.\n\n__Example__\n\n```javascript\ndb.index.drop('Person', 'name' function(err) {\n  if (!err) console.log('Index dropped!');\n});\n```\n\n\n## Legacy Index Operations\n\n**Note that as of Neo4j-2.0.0 legacy indexes are no longer the preferred way to\nhandle indexing**\n\n<a name=\"legacyindex.create\" />\n### node.legacyindex.create(name, [config,] callback)\n### rel.legacyindex.create(name, [config,] callback)\n\nCreate a new legacy index. If you're using the default legacy index configuration, \nthis method is not necessary - you can just start using the legacy index with\n[legacyindex.add](#legacyindex.add) as if it already existed.\n\n__NOTE for legacy index functions:__ there are two different types of legacy \nindex in neo4j - __node__ legacy indexes and __relationship__ legacy indexes. \nWhen you're working with __node__ legacy indexes, you use the functions on \n`node.legacyindex`.  Similarly, when you're working on __relationship__ legacy \nindexes you use the functions on `rel.legacyindex`. Most of the functions on \nboth of these are identical (excluding the uniqueness functions), but one acts \nupon node legacy indexes, and the other upon relationship legacy indexes.\n\n__Arguments__\n\n* `name` - the name of the legacy index that is being created\n* `config` (optional, default=`{}`) - the configuration of the legacy index. \nSee the [neo4j docs](http://docs.neo4j.org/chunked/milestone/rest-api-indexes.html#rest-api-create-node-index-with-configuration)\n  for more information.\n* `callback` - function(err). If `err` is falsy, the legacy index has been created.\n\n__Example__\n\n```javascript\nvar indexConfig = { type: 'fulltext', provider: 'lucene' };\ndb.node.legacyindex.create('a_fulltext_index', indexConfig, function(err) {\n  if (!err) console.log('a fulltext legacy index has been created!');\n});\n```\n\n---------------------------------------\n\n<a name=\"legacyindex.add\" />\n<a name=\"node.legacyindex\" />\n### node.legacyindex.add(indexName, id|object, key, value, callback);\n### rel.legacyindex.add(indexName, id|object, key, value, callback);\n*`node.legacyindex.add` is aliased as __node.legacyindex__ & __legacyindex__*\n\nAdd a node/relationship to a legacy index.\n\n__NOTE for legacy index functions:__ there are two different types of legacy \nindex in neo4j - __node__ legacy indexes and __relationship__ legacy indexes. \nWhen you're working with __node__ legacy indexes, you use the functions on \n`node.legacyindex`.  Similarly, when you're working on __relationship__ legacy \nindexes you use the functions on `rel.legacyindex`. Most of the functions on \nboth of these are identical (excluding the uniqueness functions), but one acts \nupon node legacy indexes, and the other upon relationship legacy indexes.\n\n__Arguments__\n\n* `indexName` - the name of the legacy index to add the node/relationship to.\n* `id | object` - the id of the node/relationship to add to the legacy index or \n  an object with an id property of the node/relationship to add to the legacy \n  index.\n* `key` - the key to index the node/relationship with\n* `value` - the value to index the node/relationship with\n* `callback` - function(err). If `err` is falsy, the node/relationship has \n  been indexed.\n\n__Example__\n\n```javascript\ndb.save({ name: 'Jon', }, function(err, node) {\n  db.legacyindex('people', node, 'name', node.name, function(err) {\n    if (!err) console.log('Jon has been indexed!');\n  });\n});\n```\n\n---------------------------------------\n\n<a name=\"legacyindex.read\" />\n### node.legacyindex.read(indexName, key, value, callback);\n### rel.legacyindex.read(indexName, key, value, callback);\n\nRead the object(s) from a legacy index that match a key-value pair. See also\n[legacyindex.readAsList](#legacyindex.readAsList).\n\n__NOTE for legacy index functions:__ there are two different types of legacy \nindex in neo4j - __node__ legacy indexes and __relationship__ legacy indexes. \nWhen you're working with __node__ legacy indexes, you use the functions on \n`node.legacyindex`.  Similarly, when you're working on __relationship__ legacy \nindexes you use the functions on `rel.legacyindex`. Most of the functions on \nboth of these are identical (excluding the uniqueness functions), but one acts \nupon node legacy indexes, and the other upon relationship legacy indexes.\n\n__Arguments__\n\n* `indexName` - the legacy index to read from\n* `key` - the key to match\n* `value` - the value to match\n* `callback` - function(err, results). `results` is a node or relationship object\n  (or an array of them if there was more than one) that matched the given \n  key-value pair in the given legacy index. If nothing matched, \n  `results === false`. [legacyindex.readAsList](#legacyindex.readAsList) is \n  similar, but always gives `results` as an array, with zero, one or more \n  elements.\n\n__Example__\n\n```javascript\ndb.rel.legacyindex.read('friendships', 'location', 'Norway', function(err, rels) {\n  // `rels` is an array of all relationships indexed in the `friendships`\n  // index, with a value `Norway` for the key `location`.\n});\n```\n\n---------------------------------------\n\n<a name=\"legacyindex.readAsList\" />\n### node.legacyindex.readAsList(indexName, key, value, callback);\n### rel.legacyindex.readAsList(indexName, key, value, callback);\n\nRead the object(s) from a legacy index that match a key-value pair. See also\n[legacyindex.read](#legacyindex.read).\n\n__NOTE for legacy index functions:__ there are two different types of legacy \nindex in neo4j - __node__ legacy indexes and __relationship__ legacy indexes. \nWhen you're working with __node__ legacy indexes, you use the functions on \n`node.legacyindex`.  Similarly, when you're working on __relationship__ legacy \nindexes you use the functions on `rel.legacyindex`. Most of the functions on \nboth of these are identical (excluding the uniqueness functions), but one acts \nupon node legacy indexes, and the other upon relationship legacy indexes.\n\n__Arguments__\n\n* `indexName` - the legacy index to read from\n* `key` - the key to match\n* `value` - the value to match\n* `callback` - function(err, results). `results` is an array of node or\n  relationship objects that matched the given key-value pair in the given legacy \n  index.  [legacyindex.read](#legacyindex.read) is similar, but gives `results` \n  as `false`, an object or an array of objects depending on the number of hits.\n\n__Example__\n\n```javascript\ndb.rel.legacyindex.readAsList('friendships', 'location', 'Norway', function(err, rels) {\n  // `rels` is an array of all relationships indexed in the `friendships`\n  // legacy index, with a value `Norway` for the key `location`.\n});\n```\n\n---------------------------------------\n\n<a name=\"legacyindex.remove\" />\n### node.legacyindex.remove(indexName, id|object, [key, [value,]] callback);\n### rel.legacyindex.remove(indexName, id|object, [key, [value,]] callback);\n\nRemove a node/relationship from a legacy index. \n\n__NOTE for legacy index functions:__ there are two different types of legacy \nindex in neo4j - __node__ legacy indexes and __relationship__ legacy indexes. \nWhen you're working with __node__ legacy indexes, you use the functions on \n`node.legacyindex`.  Similarly, when you're working on __relationship__ legacy \nindexes you use the functions on `rel.legacyindex`. Most of the functions on \nboth of these are identical (excluding the uniqueness functions), but one acts \nupon node legacy indexes, and the other upon relationship legacy indexes.\n\n__Arguments__\n\n* `indexName` - the legacy index to remove the node/relationship from.\n* `id | object` - the id of the node/relationship to remove from the legacy \n  index or an object with an id property of the node/relationship to remove from\n  the legacy index.\n* `key` (optional) - the key from which to remove the node/relationship. If none\n  is specified, every reference to the node/relationship is deleted from the\n  legacy index.\n* `value` (optional) - the value from which to remove the node/relationship. If\n  none is specified, every reference to the node/relationship is deleted for the\n  given key.\n* `callback` - function(err). If `err` is falsy, the specified references have\n  been removed.\n\n__Example__\n\n```javascript\ndb.node.legacyindex.remove('people', 6821, function(err) {\n  if (!err) console.log(\"Every reference of node 6821 has been removed from the people index\");\n});\n\ndb.rel.legacyindex.remove('friendships', 351, 'in', 'Australia', function(err) {\n  if (!err) console.log(\"Relationship 351 is no longer indexed as a friendship in Australia\");\n})\n```\n\n---------------------------------------\n\n<a name=\"legacyindex.delete\" />\n### node.legacyindex.delete(name, callback);\n### rel.legacyindex.delete(name, callback);\n\nDelete a legacy index.\n\n__NOTE for legacy index functions:__ there are two different types of legacy \nindex in neo4j - __node__ legacy indexes and __relationship__ legacy indexes. \nWhen you're working with __node__ legacy indexes, you use the functions on \n`node.legacyindex`.  Similarly, when you're working on __relationship__ legacy \nindexes you use the functions on `rel.legacyindex`. Most of the functions on \nboth of these are identical (excluding the uniqueness functions), but one acts \nupon node legacy indexes, and the other upon relationship legacy indexes.\n\n__Arguments__\n\n* `name` - the name of the legacy index to delete\n* `callback` - function(err). if `err` is falsy, the legacy index has been deleted.\n\n__Example__\n\n```javascript\ndb.rel.legacyindex.delete('friendships', function(err) {\n  if (!err) console.log('The `friendships` index has been deleted');\n})\n```\n\n---------------------------------------\n\n<a name=\"legacyindex.getOrSaveUnique\" />\n### node.legacyindex.getOrSaveUnique(node, index, key, value, callback);\n### rel.legacyindex.getOrSaveUnique(startNode, relName, endNode, [properties,] index, key, value, callback);\n\nSave a node or relationship, using a legacy index to enforce uniqueness. If \nthere is already a node or relationship saved under the specified `key` and \n`value` in the specified `index`, that node or relationship will be returned.\n\nNote that you cannot use this function to update nodes.\n\n__NOTE for legacy index functions:__ there are two different types of legacy \nindex in neo4j - __node__ legacy indexes and __relationship__ legacy indexes. \nWhen you're working with __node__ legacy indexes, you use the functions on \n`node.legacyindex`.  Similarly, when you're working on __relationship__ legacy \nindexes you use the functions on `rel.legacyindex`. Most of the functions on \nboth of these are identical (excluding the uniqueness functions), but one acts \nupon node legacy indexes, and the other upon relationship legacy indexes.\n\n__Arguments (node)__\n\n* `node` - the node to save\n* `index` - the name of the legacy index in which `key` and `value` are relevant\n* `key` - the key to check or store under\n* `value` - the value to check or store under\n* `callback` - function(err, node) - returns your saved node, or the node that\n  was referenced by the specified `key` and `value` if one already existed.\n\n__Arguments (relationship)__ \n* `startNode` - the start point of the relationship (object containing id or id)\n* `relName` - the name of the relationship to create\n* `endNode` - the end point of the relationship (object containing id or id)\n* `properties` (optional) - an object containing properties to store on the\n  created relationship.\n* `index` - the name of the legacy index in which `key` and `value` are relevant\n* `key` - the key to check or store under\n* `value` - the value to check or store under\n* `callback` - function(err, rel) - returns your created relationship, or the \n  relationship that was referenced by the specified `key` and `value` if one \n  already existed.\n\n__Example__\n\n```javascript\nvar tag = { name: 'finnish' };\ndb.node.legacyindex.getOrSaveUnique(tag, 'tags', 'name', tag.name, function(err, tag) {\n  // tag == { id: 1, name: 'finnish' }\n\n  // save another new object with the same properties\n  db.node.legacyindex.getOrSaveUnique({name: 'finnish'}, 'tags', 'name', 'finnish', function(err, newTag) {\n    // newTag == { id: 1, name: 'finnish' }\n    // no save was performed because there was already an object at that index\n  });\n});\n```\n\n---------------------------------------\n\n<a name=\"legacyindex.saveUniqueOrFail\" />\n### node.legacyindex.saveUniqueOrFail(node, index, key, value, callback);\n### rel.legacyindex.saveUniqueOrFail(startNode, relName, endNode, [properties,] index, key, value, callback);\n\nSave a node or relationship, using a legacy index to enforce uniqueness. If \nthere is already a node or relationship saved under the specified `key` and \n`value` in the specified `index`, an error is returned indicating that there \nas a conflict. You can check if the result was a conflict by checking if \n`err.statusCode == 409`.\n\n__NOTE for legacy index functions:__ there are two different types of legacy \nindex in neo4j - __node__ legacy indexes and __relationship__ legacy indexes. \nWhen you're working with __node__ legacy indexes, you use the functions on \n`node.legacyindex`.  Similarly, when you're working on __relationship__ legacy \nindexes you use the functions on `rel.legacyindex`. Most of the functions on \nboth of these are identical (excluding the uniqueness functions), but one acts \nupon node legacy indexes, and the other upon relationship legacy indexes.\n\n__Arguments (node)__\n\n* `node` - the node to save\n* `index` - the name of the legacy index in which `key` and `value` are relevant\n* `key` - the key to check or store under\n* `value` - the value to check or store under\n* `callback` - function(err, node) - returns your created node, or an err with \n  `statusCode == 409` if a node already existed at that legacy index\n\n__Arguments (relationship)__ \n* `startNode` - the start point of the relationship (object containing id or id)\n* `relName` - the name of the relationship to create\n* `endNode` - the end point of the relationship (object containing id or id)\n* `properties` (optional) - an object containing properties to store on the\n  created relationship.\n* `index` - the name of the legacy index in which `key` and `value` are relevant\n* `key` - the key to check or store under\n* `value` - the value to check or store under\n* `callback` - function(err, rel) - returns your created relationship, or an \n  err with `statusCode == 409` if a relationship already existed at that legacy \n  index\n\n__Example__\n\n```javascript\nvar tag = { name: 'finnish' };\ndb.node.legacyindex.saveUniqueOrFail(tag, 'tags', 'name', tag.name, function(err, tag) {\n  // tag == { id: 1, name: 'finnish' }\n\n  // save another new object with the same properties\n  db.node.legacyindex.saveUniqueOrFail({name: 'finnish'}, 'tags', 'name', 'finnish', function(err, newTag) {\n    // newTag == undefined\n    // err.statusCode == 409 (conflict)\n    // an error was thrown because there was already a node at that index.\n  });\n});\n```\n\n---------------------------------------\n\nDevelopment of Seraph is lovingly sponsored by \n[BRIK Tekonologier AS](http://www.github.com/brikteknologier) in Bergen, Norway.\n\n<img src=\"http://i.imgur.com/9JjcBcx.jpg\" width=\"800\"/>\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/brikteknologier/seraph/issues"
  },
  "homepage": "https://github.com/brikteknologier/seraph",
  "_id": "seraph@0.9.4",
  "_from": "seraph@0.9.x"
}
